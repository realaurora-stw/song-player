<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synced Lyrics Player</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            font-family: 'Poppins', sans-serif;
            background-color: #000000;
            color: #f0f0f0;
            overflow: hidden;
        }

        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        button, input, select, textarea {
            font-family: inherit;
        }

        #lyrics-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 40px 5% 200px 5%;
            font-size: 2.8em;
            line-height: 1.6;
            display: flex;
            scroll-behavior: smooth;
            scrollbar-gutter: stable;
            min-height: 0;
        }

        #lyrics-output {
            max-width: 900px;
            width: 100%;
            text-align: left;
        }


        #lyrics-output span {
            display: none;
            opacity: 0;

            transform: translateY(15px) scale(0.9);
            transform-origin: center left;
            color: #f0f0f0;
            margin: 0 0.1em;
            cursor: default;

            transition: opacity 0.45s ease-out,
                        transform 0.45s ease-out,
                        color 0.25s ease-in-out,
                        font-weight 0.25s ease-in-out;
            will-change: opacity, transform;
            pointer-events: none;
        }

        #lyrics-output span.visible {
            display: inline-block;
            opacity: 1;

            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        #lyrics-output span.highlighted {
            color: #50d060;
            font-weight: 600;

            transform: translateY(-1px) scale(1.05);

        }


        #lyrics-output.placeholder {
             display: block;
             opacity: 1;
             transform: none;
             color: #555;
             font-style: italic;
             text-align: center;
             margin: auto;
             font-weight: normal;
        }

        #controls-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #000000;
            padding: 15px 30px;
            border-top: 1px solid #0c0c0c;
            z-index: 10;
            color: #aaa;
        }

        .file-inputs {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .file-inputs label {
            font-size: 0.9em;
        }

        .file-inputs input[type="file"] {
            font-size: 0.8em;
            max-width: 250px;
            color: #aaa;
            font-family: inherit;
        }
        .file-inputs input[type="file"]::file-selector-button {
            padding: 5px 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #222;
            color: #ccc;
            cursor: pointer;
            font-size: 0.9em;
            margin-right: 10px;
            transition: background-color 0.2s;
            font-family: inherit;
        }
        .file-inputs input[type="file"]::file-selector-button:hover {
            background-color: #333;
        }

        .player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            position: relative;
        }

        #playPauseBtn {
            background-color: #141414;
            color: #eee;
            border: none;
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 12px;
            cursor: pointer;
            min-width: 80px;
            transition: background-color 0.2s;
            font-family: inherit;
        }

        #playPauseBtn:disabled {
            background-color: #141414;
            color: #666;
            cursor: not-allowed;
        }

        #progressBar {
            flex-grow: 1;
            max-width: 500px;
            cursor: pointer;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #0d0d0d;
            border-radius: 5px;
            outline: none;
        }
        #progressBar::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 16px;
          height: 16px;
          background: #1c1c1c;
          border-radius: 50%;
          cursor: pointer;
          /* Attempt at smooth visual transition for seeks */
          transition: background-color 0.2s, transform 0.15s ease-out;
        }
         #progressBar:hover::-webkit-slider-thumb {
              background: #2e2e2e;
         }

        #progressBar::-moz-range-thumb {
          width: 16px;
          height: 16px;
          background: #666;
          border-radius: 50%;
          cursor: pointer;
          border: none;
           /* Attempt at smooth visual transition for seeks */
          transition: background-color 0.2s, transform 0.15s ease-out;
        }

        #progressBar:disabled::-webkit-slider-thumb {
            cursor: not-allowed;
            transition: none; /* Disable transition when disabled */
        }
        #progressBar:disabled::-moz-range-thumb {
            cursor: not-allowed;
             transition: none; /* Disable transition when disabled */
        }
        #progressBar:disabled {
            cursor: not-allowed;
        }


        #currentTime, #totalDuration {
            font-size: 0.9em;
            min-width: 45px;
            text-align: center;
            color: #aaa;
            font-family: inherit;
            white-space: nowrap;
        }

        #audioPlayer {
             display: none;
        }

        #loadStatus {
             font-size: 0.8em;
             color: #888;
             margin-left: 15px;
             min-height: 1.2em;
             font-family: inherit;
        }

       .control-icon-btn {
            background: none;
            border: none;
            color: #aaa;
            font-size: 1.2em;
            padding: 5px;
            cursor: pointer;
            transition: color 0.2s;
            line-height: 1;
            font-family: inherit;
       }
       .control-icon-btn:hover:enabled {
           color: #eee;
       }
       .control-icon-btn:disabled {
           color: #555;
           cursor: not-allowed;
       }

        .volume-control-wrapper,
        .speed-control-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .popup-control {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background-color: #111111;
            padding: 15px 15px 15px 15px;
            border-radius: 12px;
            box-shadow: 0px -2px 10px rgba(0, 0, 0, 0.5);
            z-index: 20;
            width: 50px;
            height: 160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.25s ease-out, transform 0.25s ease-out, visibility 0s 0.25s;
            will-change: opacity, transform, visibility;
        }

        .slider-wrapper-vertical {
            width: 90px;
            height: 24px;
            transform: rotate(-90deg);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }

        .slider-vertical {
            -webkit-appearance: none;
            appearance: none;
            width: 90px;
            height: 8px;
            cursor: pointer;
            background: #2c2c2c;
            border-radius: 10px;
            outline: none;
            display: block;
            margin: 0;
            margin-right: 56px;

        }

        .slider-vertical::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; background: #ccc;
            border-radius: 50%; cursor: pointer; border: none;
        }
        .slider-vertical::-moz-range-thumb {
            width: 16px; height: 16px; background: #ccc;
            border-radius: 50%; cursor: pointer; border: none;
        }

        .slider-vertical:disabled { cursor: not-allowed; background: #444; }
        .slider-vertical:disabled::-webkit-slider-thumb { background: #666; cursor: not-allowed; }
        .slider-vertical:disabled::-moz-range-thumb { background: #666; cursor: not-allowed; }

        .popup-text-display {
            color: #f0f0f0;
            font-size: 0.8em;
            text-align: center;
            width: 100%;
            margin-top: auto;
            font-family: inherit;
        }

        .popup-control.show {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out, visibility 0s 0s;
        }


        @media (max-width: 768px) {
             #lyrics-container {
                 font-size: 2em;
                 padding: 20px 5% 150px 5%;
             }
             .player-controls { gap: 10px; }
             #playPauseBtn { padding: 6px 10px; font-size: 0.9em; }
            #currentTime, #totalDuration { font-size: 0.8em; min-width: 40px; }
            .file-inputs label { font-size: 0.8em; }
           .control-icon-btn { font-size: 1.1em; }

           .popup-control {
               padding: 12px 10px 12px 10px;
               height: 140px;
           }
           .slider-wrapper-vertical {
               width: 75px;
               height: 22px;
               margin-bottom: 15px;
           }
           .slider-vertical {
               width: 75px;
               height: 6px;
           }
            .slider-vertical::-webkit-slider-thumb { width: 14px; height: 14px; }
            .slider-vertical::-moz-range-thumb { width: 14px; height: 14px; }
           .popup-text-display { font-size: 0.75em; }
        }
    </style>
</head>
<body>

    <div id="lyrics-container">
        <p id="lyrics-output" class="placeholder">Load a .songlyrics file.</p>
    </div>

    <div id="controls-container">
        <div class="file-inputs">
            <input type="file" id="songLyricsFile" accept=".songlyrics">
             <span id="loadStatus"></span>
        </div>
        <audio id="audioPlayer" style="display: none;"></audio>
        <div class="player-controls">
            <button id="playPauseBtn" disabled>▶ Play</button>
            <span id="currentTime">0:00</span>
            <input type="range" id="progressBar" value="0" step="0.1" disabled>
            <span id="totalDuration">0:00</span>

            <div class="volume-control-wrapper">
                <button id="volumeBtn" class="control-icon-btn" disabled title="Volume">
                    <i class="fas fa-volume-up"></i>
                </button>
                <div id="volumePopup" class="popup-control">
                    <div class="slider-wrapper-vertical">
                        <input type="range" id="volumeSlider" class="slider-vertical" min="0" max="1" step="0.01" value="1">
                    </div>
                    <span id="volumePercentage" class="popup-text-display">100%</span>
                </div>
            </div>

            <div class="speed-control-wrapper">
                <button id="speedBtn" class="control-icon-btn" disabled title="Playback Speed & Pitch">
                    <i class="fas fa-sliders-h"></i>
                </button>
                <div id="speedPopup" class="popup-control">
                    <div class="slider-wrapper-vertical">
                        <input type="range" id="speedSlider" class="slider-vertical" min="0.3" max="2" step="0.01" value="1">
                    </div>
                    <span id="speedRateDisplay" class="popup-text-display">1.00x</span>
                </div>
            </div>
        </div>
    </div>

    <script>

        const songLyricsFileInput = document.getElementById('songLyricsFile');
        const lyricsOutput = document.getElementById('lyrics-output');
        const lyricsContainer = document.getElementById('lyrics-container');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const progressBar = document.getElementById('progressBar');
        const currentTimeDisplay = document.getElementById('currentTime');
        const totalDurationDisplay = document.getElementById('totalDuration');
        const loadStatus = document.getElementById('loadStatus');
        const volumeBtn = document.getElementById('volumeBtn');
        const volumePopup = document.getElementById('volumePopup');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeIcon = volumeBtn.querySelector('i');
        const volumePercentage = document.getElementById('volumePercentage');
        const speedBtn = document.getElementById('speedBtn');
        const speedPopup = document.getElementById('speedPopup');
        const speedSlider = document.getElementById('speedSlider');
        const speedRateDisplay = document.getElementById('speedRateDisplay');


        let audioContext;
        let audioBuffer;
        let sourceNode;
        let gainNode;
        let isPlaying = false;
        let isPaused = false;
        let startTime = 0;
        let startOffset = 0;
        let currentPlaybackRate = 1.0;
        let animationFrameId = null;


        let lyricsData = [];
        let currentWordSpans = [];
        let currentWordIndex = -1;
        let previousWordIndex = -1;
        let audioLoaded = false;
        let lyricsLoaded = false;
        let isSeeking = false;


        const VOLUME_STORAGE_KEY = 'playerVolumeSetting';
        const SPEED_STORAGE_KEY = 'playerSpeedSetting_v2';


        function initializeAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    gainNode = audioContext.createGain();
                    gainNode.connect(audioContext.destination);
                    console.log("AudioContext initialized.");
                    loadVolumeSetting();
                    loadSpeedSetting();
                } catch (e) {
                    console.error("Web Audio API is not supported.", e);
                    alert("Web Audio API is required.");
                    audioContext = null;
                }
            }
        }
        loadVolumeSetting();
        loadSpeedSetting();
        resetPlayerAndLyrics(false);


        songLyricsFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            resetPlayerAndLyrics(false);
            loadStatus.textContent = '';
            if (!file) return;

            if (!file.name.toLowerCase().endsWith('.songlyrics')) {
                alert('Invalid file type. Please select a .songlyrics file.');
                songLyricsFileInput.value = '';
                resetPlayerAndLyrics(false);
                return;
            }
            initializeAudioContext();
            if (!audioContext) {
                loadStatus.textContent = 'Error: AudioContext failed.';
                resetPlayerAndLyrics(true);
                return;
            }
            loadStatus.textContent = `Loading ${file.name}...`;
            const reader = new FileReader();
            reader.onload = (e) => parseCombinedFile(e.target.result);
            reader.onerror = () => {
                alert("Error reading file.");
                loadStatus.textContent = 'Error reading file.';
                resetPlayerAndLyrics(true);
            };
            reader.readAsArrayBuffer(file);
        });

        volumeBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            if (!volumeBtn.disabled) { togglePopup(volumePopup); hidePopup(speedPopup); }
        });

        volumeSlider.addEventListener('input', () => {
            if (!volumeSlider.disabled && gainNode && audioContext) {
                const volume = parseFloat(volumeSlider.value);
                setVolume(volume); // Use helper function
            }
        });

        speedBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            if (!speedBtn.disabled) { togglePopup(speedPopup); hidePopup(volumePopup); }
        });

        speedSlider.addEventListener('input', () => {
            if (!speedSlider.disabled && audioBuffer && audioContext) {
                const rate = parseFloat(speedSlider.value);
                if (rate === currentPlaybackRate) return;
                const previousRate = currentPlaybackRate;
                currentPlaybackRate = rate;
                speedRateDisplay.textContent = `${rate.toFixed(2)}x`;
                saveSetting(SPEED_STORAGE_KEY, rate);
                updateTotalDurationDisplay();
                if (isPlaying && sourceNode?.playbackRate) {
                    const elapsedRealTime = audioContext.currentTime - startTime;
                    const elapsedBufferTime = elapsedRealTime * previousRate;
                    startOffset = (startOffset + elapsedBufferTime) % audioBuffer.duration;
                    startOffset = Math.max(0, startOffset);
                    sourceNode.playbackRate.setValueAtTime(currentPlaybackRate, audioContext.currentTime);
                    startTime = audioContext.currentTime;
                    console.log(`Speed changed while playing: ${rate.toFixed(2)}x. Offset: ${startOffset.toFixed(3)}`);
                } else if (sourceNode?.playbackRate) {
                    sourceNode.playbackRate.setValueAtTime(currentPlaybackRate, audioContext.currentTime);
                    console.log(`Speed changed while paused/inactive: ${rate.toFixed(2)}x.`);
                }
                 // Update time display immediately based on new rate and current offset
                updateCurrentTimeDisplay(startOffset);
            }
        });

        document.addEventListener('click', (event) => {
            if (volumePopup.classList.contains('show') && !volumeBtn.contains(event.target) && !volumePopup.contains(event.target)) hidePopup(volumePopup);
            if (speedPopup.classList.contains('show') && !speedBtn.contains(event.target) && !speedPopup.contains(event.target)) hidePopup(speedPopup);
        });

        volumePopup.addEventListener('click', (event) => event.stopPropagation());
        speedPopup.addEventListener('click', (event) => event.stopPropagation());

        playPauseBtn.addEventListener('click', () => {
            if (!audioLoaded || !lyricsLoaded || !audioContext) return;
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(togglePlayback).catch(e => console.error("Resume failed:", e));
            } else {
                togglePlayback();
            }
        });

        progressBar.addEventListener('input', () => {
            if (!audioLoaded || !lyricsLoaded || !audioBuffer || !audioContext) return;
            isSeeking = true;
            stopUpdatingTime();
            const seekBufferTime = parseFloat(progressBar.value);
            updateCurrentTimeDisplay(seekBufferTime);
            updateLyricsHighlight(seekBufferTime, true, false);
        });

        progressBar.addEventListener('change', () => {
            if (!audioLoaded || !lyricsLoaded || !audioBuffer || !audioContext) return;
            const seekBufferTime = parseFloat(progressBar.value);
            seekAudio(seekBufferTime); // Seek to the final position
            isSeeking = false;
            if (isPlaying) {
                // seekAudio restarts playback if it was playing
                // startUpdatingTime will be called within playAudio called by seekAudio
            } else {
                 // Ensure UI is updated correctly if paused after seeking
                updateCurrentTimeDisplay(startOffset); // Update with the final startOffset
                updateLyricsHighlight(startOffset, true, false);
            }
        });


        function loadSetting(key, defaultValue, validator) {
             try {
                const savedValue = localStorage.getItem(key);
                if (savedValue !== null) {
                    const parsedValue = parseFloat(savedValue);
                    if (validator(parsedValue)) return parsedValue;
                    localStorage.removeItem(key);
                }
            } catch (e) { console.error("Error loading setting:", e); }
            return defaultValue;
        }
        function saveSetting(key, value) { try { localStorage.setItem(key, value.toString()); } catch (e) { console.error("Error saving setting:", e); }}

        function loadVolumeSetting() {
            const vol = loadSetting(VOLUME_STORAGE_KEY, 1, v => !isNaN(v) && v>=0 && v<=1);
            if(gainNode && audioContext) gainNode.gain.value = vol; // Set initial value directly
            else if (!gainNode && typeof vol === 'number') volumeSlider.value = vol; // Fallback if context not ready

            if(volumeSlider) volumeSlider.value = vol;
            if(volumePercentage) volumePercentage.textContent = `${Math.round(vol * 100)}%`;
            updateVolumeIcon(vol);
        }
        function loadSpeedSetting() {
            const speed = loadSetting(SPEED_STORAGE_KEY, 1, s => !isNaN(s) && s>=0.3 && s<=2);
            currentPlaybackRate = speed;
            if(speedSlider) speedSlider.value = speed;
            if(speedRateDisplay) speedRateDisplay.textContent = `${speed.toFixed(2)}x`;
            updateTotalDurationDisplay(); // Update duration based on loaded speed
        }


        function updateTotalDurationDisplay() {
             if (audioBuffer?.duration > 0 && currentPlaybackRate > 0) {
                const adjustedDuration = audioBuffer.duration / currentPlaybackRate;
                totalDurationDisplay.textContent = formatTime(adjustedDuration);
                progressBar.max = audioBuffer.duration; // Max is always buffer duration
            } else {
                totalDurationDisplay.textContent = '0:00';
                progressBar.max = 1;
            }
        }
        function updateCurrentTimeDisplay(bufferTime) {
             // Ensure bufferTime is valid before calculations
             const validBufferTime = (typeof bufferTime === 'number' && isFinite(bufferTime)) ? bufferTime : 0;
             const duration = audioBuffer?.duration ?? 0;
             const clampedBufferTime = Math.max(0, Math.min(validBufferTime, duration));

             if (duration > 0 && currentPlaybackRate > 0) {
                const adjustedTime = clampedBufferTime / currentPlaybackRate;
                currentTimeDisplay.textContent = formatTime(adjustedTime);
                if (!isSeeking) { // Only update slider value if not manually seeking via drag
                     progressBar.value = clampedBufferTime;
                }
             } else {
                 currentTimeDisplay.textContent = '0:00';
                 if (!isSeeking) {
                     progressBar.value = 0;
                 }
             }
        }


        function parseCombinedFile(arrayBuffer) {
            resetPlayerAndLyrics(false);
            try {
                const dataView = new DataView(arrayBuffer); let offset = 0;
                const magic = String.fromCharCode(...Array(4).fill().map(() => dataView.getUint8(offset++)));
                if (magic !== "LYRX") throw new Error("Invalid magic bytes.");
                const jsonLength = dataView.getUint32(offset, false); offset += 4;
                if (jsonLength <= 0 || offset + jsonLength > arrayBuffer.byteLength) throw new Error("Invalid JSON length.");
                const jsonString = new TextDecoder().decode(new Uint8Array(arrayBuffer, offset, jsonLength)); offset += jsonLength;
                const jsonData = JSON.parse(jsonString);
                lyricsData = [];
                if (jsonData?.segments) {
                    jsonData.segments.forEach(s => s.words?.forEach(w => {if(w.type === 'word') lyricsData.push({word: w.text, start: w.start})}));
                } else if (Array.isArray(jsonData)) {
                    jsonData.forEach(i => {if(i?.word && typeof i.start === 'number') lyricsData.push({word: i.word, start: i.start})});
                }
                lyricsLoaded = lyricsData.length > 0;
                renderLyrics();
                const audioData = arrayBuffer.slice(offset);
                if (audioData.byteLength === 0) throw new Error("Missing audio data.");
                if (!audioContext) throw new Error("AudioContext not ready.");
                audioContext.decodeAudioData(audioData)
                    .then(buffer => {
                        if (!(buffer?.duration > 0)) throw new Error("Decoded audio has invalid duration.");
                        audioBuffer = buffer; audioLoaded = true;
                        console.log("Audio decoded. Duration:", buffer.duration);
                        progressBar.max = buffer.duration;
                        updateTotalDurationDisplay(); updateCurrentTimeDisplay(0);
                        if(lyricsLoaded) updateLyricsHighlight(0, true, false);
                        loadStatus.textContent = 'File loaded.'; checkEnablePlayer();
                    }).catch(e => { throw new Error(`Audio decode error: ${e.message}`); });
            } catch (error) {
                alert(`File processing error: ${error.message}`); console.error("Parse Error:", error);
                resetPlayerAndLyrics(true);
            }
        }


        function togglePlayback() { if (isPlaying) pauseAudio(); else playAudio(); }
        function playAudio() {
            if (!audioContext || !audioBuffer || isPlaying) return;
            if (audioContext.state === 'suspended') { audioContext.resume().then(playAudioInternal); return; }
            playAudioInternal();
        }
        function playAudioInternal() {
            if (isPlaying) return; // Should not happen but safety check
            // Ensure startOffset is within bounds before starting
            startOffset = Math.max(0, Math.min(startOffset, audioBuffer.duration));
             // Handle potential edge case where startOffset might be exactly duration
            if (startOffset >= audioBuffer.duration) { startOffset = 0; }

            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.playbackRate.setValueAtTime(currentPlaybackRate, audioContext.currentTime);
            sourceNode.loop = true; // Loop is handled manually by time update logic now
            sourceNode.connect(gainNode);
            sourceNode.onended = handleAudioEnd; // Use onended primarily for cleanup/state correction

            startTime = audioContext.currentTime; // Record the precise time playback *starts*
            sourceNode.start(0, startOffset); // Start playback from the current offset

            isPlaying = true; isPaused = false;
            playPauseBtn.textContent = '❚❚ Pause';
            startUpdatingTime(); // Start the loop to update time and lyrics
            console.log(`Playback started/resumed. Offset: ${startOffset.toFixed(3)}`);
        }
        function pauseAudio() {
            if (!isPlaying || !sourceNode || !audioContext) return;
            // Calculate elapsed buffer time since last start/resume
            const elapsedRealTime = audioContext.currentTime - startTime;
            const elapsedBufferTime = elapsedRealTime * currentPlaybackRate;
            // Update startOffset to the current position
            startOffset = (startOffset + elapsedBufferTime); // No modulo here, let seek/play handle loop wrap
            // Clamp offset just in case
             startOffset = Math.max(0, Math.min(startOffset, audioBuffer.duration));


            stopAudioInternals(); // Stop source node and cancel animation frame

            isPlaying = false; isPaused = true;
            playPauseBtn.textContent = '▶ Play';

            console.log(`Playback paused at offset: ${startOffset.toFixed(3)}`);
             // Update display to show the exact paused time
            updateCurrentTimeDisplay(startOffset);
             // Optionally update lyrics highlight to exact pause point
             // updateLyricsHighlight(startOffset, true, false); // Might cause flicker if resuming quickly
        }
        // Internal helper to stop audio source and animation frame
        function stopAudioInternals() {
             if (sourceNode) {
                sourceNode.onended = null; // Remove listener before stopping
                sourceNode.loop = false; // Ensure looping is off
                try {
                    sourceNode.stop(0); // Stop playback immediately
                } catch (e) {
                    // Ignore errors if already stopped or context closed
                    // console.warn("Stop error (ignored):", e.message);
                 }
                sourceNode.disconnect(); // Disconnect from graph
                sourceNode = null;
            }
            stopUpdatingTime(); // Cancel animation frame loop
        }
        // Function to completely stop playback and reset state (e.g., when seeking or resetting)
        function stopAudio() {
            stopAudioInternals(); // Stop source and timer
            isPlaying = false; // Ensure playing state is false
            // isPaused state depends on context (seeking might reset it)
        }

        function seekAudio(bufferTime) {
            if (!audioBuffer || !audioContext) return;

            const wasPlaying = isPlaying;
            stopAudio(); // Stop current playback and timer

            // Set the new offset, ensuring it's within bounds [0, duration]
            startOffset = Math.max(0, bufferTime);
            startOffset = Math.min(startOffset, audioBuffer.duration);
             // Handle edge case: if seeking exactly to the end, wrap to beginning? Or allow?
             // Let's allow seeking to the very end, playback will stop/loop correctly.

            console.log(`Seeking to buffer time: ${startOffset.toFixed(3)}`);

            // Update UI immediately to reflect the seek target
            progressBar.value = startOffset; // Update progress bar visually
            updateCurrentTimeDisplay(startOffset); // Update time display
            updateLyricsHighlight(startOffset, true, false); // Force update lyrics highlight

            if (wasPlaying) {
                 playAudio(); // Restart playback from the new startOffset
            } else {
                // If it was paused, remain paused at the new location
                isPaused = true; // Ensure paused state is set
                playPauseBtn.textContent = '▶ Play';
                // UI already updated above
            }
        }

        function handleAudioEnd() {
             // This might be called if stop() is called, or if buffer naturally ends (though loop=true complicates this)
             // console.log("Source ended event triggered. isPlaying:", isPlaying, "isPaused:", isPaused, "Current Offset:", startOffset.toFixed(3));

             // If the source ended but we think we are playing (e.g. unexpected stop), transition to paused state
             if (isPlaying && !isPaused) {
                 console.warn("Audio source ended unexpectedly while 'isPlaying' was true. Transitioning to paused state.");
                 // Recalculate offset based on duration as it likely reached the end
                 startOffset = audioBuffer?.duration ?? startOffset; // Assume it reached end
                 pauseAudio(); // Correctly transition state
             } else {
                 // If it ended while paused or stopped normally, just ensure sourceNode is null
                 sourceNode = null;
             }
        }


        function startUpdatingTime() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            // Ensure startTime is valid before starting loop
            if (!isPlaying || startTime <= 0 || !audioContext) startTime = audioContext.currentTime;

            function updateLoop() {
                if (!isPlaying || !audioBuffer || !sourceNode || !audioContext) {
                    animationFrameId = null; return; // Stop loop if state is invalid
                }

                const elapsedRealTime = audioContext.currentTime - startTime;
                let currentBufferTime = startOffset + (elapsedRealTime * currentPlaybackRate);

                // Handle looping: if currentBufferTime exceeds duration, wrap around
                if (currentBufferTime >= audioBuffer.duration) {
                    console.log("Loop detected in update loop.");
                    // Calculate how much time has passed since the loop point
                    const timeIntoNextLoop = currentBufferTime - audioBuffer.duration;
                    // Reset startOffset for the next frame calculation (conceptual start of the loop)
                    startOffset = 0;
                    // Reset startTime to current time for accurate delta next frame
                    startTime = audioContext.currentTime;
                     // The actual buffer time for this frame *is* the overflow amount
                    currentBufferTime = timeIntoNextLoop % audioBuffer.duration;

                     // Force lyrics update and scroll to top smoothly upon loop
                    updateLyricsHighlight(currentBufferTime, true, true); // Force update, allow scroll
                    lyricsContainer.scrollTo({ top: 0, behavior: 'smooth' });

                } else {
                     // Normal update within the duration
                     updateLyricsHighlight(currentBufferTime, false, true); // Normal update, allow scroll
                }

                // Update time display and progress bar (only if not manually seeking)
                if (!isSeeking) {
                    updateCurrentTimeDisplay(currentBufferTime);
                }

                // Continue the loop
                animationFrameId = requestAnimationFrame(updateLoop);
            }
            animationFrameId = requestAnimationFrame(updateLoop);
        }

        function stopUpdatingTime() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }


        function checkEnablePlayer() {
            const enabled = audioLoaded && lyricsLoaded && !!audioContext;
            playPauseBtn.disabled = !enabled; progressBar.disabled = !enabled;
            volumeBtn.disabled = !enabled; volumeSlider.disabled = !enabled;
            speedBtn.disabled = !enabled; speedSlider.disabled = !enabled;
            if (!enabled) { hidePopup(volumePopup); hidePopup(speedPopup); }
            // Ensure UI reflects current state even when disabling/enabling
            const currentVolume = gainNode ? gainNode.gain.value : parseFloat(volumeSlider.value);
            updateVolumeIcon(currentVolume);
            volumePercentage.textContent = `${Math.round(currentVolume * 100)}%`;
            speedRateDisplay.textContent = `${currentPlaybackRate.toFixed(2)}x`;
            updateTotalDurationDisplay();
            updateCurrentTimeDisplay(startOffset); // Reflect current offset
        }
        function resetPlayerAndLyrics(resetSettings = false) {
            stopAudio(); // Stop any playing audio and timer
            audioLoaded = false; lyricsLoaded = false; audioBuffer = null;
            lyricsData = []; currentWordSpans = [];
            currentWordIndex = -1; previousWordIndex = -1;
            startOffset = 0; startTime = 0; isPaused = false; isPlaying = false; // Ensure isPlaying is reset
            lyricsOutput.innerHTML = 'Load a .songlyrics file.'; lyricsOutput.className = 'placeholder';
            lyricsContainer.style.justifyContent = 'center'; lyricsContainer.style.alignItems = 'center';
            lyricsContainer.scrollTop = 0;
            playPauseBtn.textContent = '▶ Play'; progressBar.value = 0; progressBar.max = 1;
            currentTimeDisplay.textContent = '0:00'; totalDurationDisplay.textContent = '0:00'; loadStatus.textContent = '';
            if (resetSettings) {
                const defVol = 1, defSpd = 1.0;
                 setVolume(defVol); // Use helper
                 saveSetting(VOLUME_STORAGE_KEY, defVol); // Save default

                 currentPlaybackRate = defSpd;
                 speedSlider.value = defSpd;
                 speedRateDisplay.textContent = `${defSpd.toFixed(2)}x`;
                 saveSetting(SPEED_STORAGE_KEY, defSpd);
                 updateTotalDurationDisplay(); // Update duration based on reset speed

            } else {
                 loadVolumeSetting();
                 loadSpeedSetting();
                 // Update displays based on loaded settings
                 updateTotalDurationDisplay();
            }
            hidePopup(volumePopup); hidePopup(speedPopup);
            checkEnablePlayer(); // Disable controls
        }


        function renderLyrics() {
            lyricsOutput.innerHTML = ''; lyricsOutput.className = '';
            lyricsContainer.style.justifyContent = 'flex-start'; lyricsContainer.style.alignItems = 'flex-start';
            currentWordSpans = []; currentWordIndex = -1; previousWordIndex = -1;
            lyricsContainer.scrollTop = 0;
            if (lyricsData.length > 0) {
                lyricsData.forEach((line, index) => {
                    const span = document.createElement('span'); span.textContent = line.word + ' ';
                    span.id = `word-${index}`; span.dataset.startTime = line.start;
                    lyricsOutput.appendChild(span); currentWordSpans.push(span);
                });
                updateLyricsHighlight(startOffset, true, false); // Initial highlight based on startOffset
            } else {
                lyricsOutput.innerHTML = 'No valid lyrics found.'; lyricsOutput.className = 'placeholder';
                lyricsContainer.style.justifyContent = 'center'; lyricsContainer.style.alignItems = 'center';
                lyricsLoaded = false;
            }
        }
        function updateLyricsHighlight(currentBufferTime, forceUpdate = false, allowScroll = false) {
            // Use modulo for effective time within the buffer duration
            const effectiveTime = audioBuffer ? (currentBufferTime % audioBuffer.duration) : 0;

            if (!lyricsLoaded || currentWordSpans.length === 0) {
                // Clear highlights if no lyrics or spans
                 if (currentWordIndex !== -1) {
                     highlightWord(-1, false); // Clear highlight
                     currentWordIndex = -1;
                     previousWordIndex = -1;
                 }
                return;
            }

            // Find the index of the word that should be highlighted
            let newWordIndex = -1;
            for (let i = 0; i < lyricsData.length; i++) {
                // Highlight word slightly before its exact start time for better sync feel
                if (lyricsData[i].start <= effectiveTime + 0.05) {
                    newWordIndex = i;
                } else {
                    break; // Words are sorted by time, no need to check further
                }
            }

            // Check if the index actually changed or if a forced update is requested
             if (newWordIndex !== currentWordIndex || forceUpdate) {
                 // Don't scroll immediately if seeking, let seekAudio handle initial scroll
                const shouldScroll = allowScroll && !isSeeking && isPlaying;
                highlightWord(newWordIndex, shouldScroll);
                previousWordIndex = currentWordIndex; // Track previous index
                currentWordIndex = newWordIndex; // Update current index
             }
        }

        function highlightWord(indexToHighlight, shouldAutoScroll = false) {
            let wordToScroll = null;
            currentWordSpans.forEach((span, index) => {
                // A word is 'visible' if it's the highlighted word or any word before it
                const isVisible = index <= indexToHighlight;
                span.classList.toggle('visible', isVisible);

                // Only the exact word at indexToHighlight gets the 'highlighted' class
                const isHighlighted = index === indexToHighlight;
                span.classList.toggle('highlighted', isHighlighted);

                if(isHighlighted) {
                    wordToScroll = span; // Identify the highlighted span for scrolling
                }
            });

             // If index is -1 (e.g., beginning or no lyrics), remove all classes
             if (indexToHighlight < 0) {
                 currentWordSpans.forEach(s => s.classList.remove('highlighted', 'visible'));
             }

            // Auto-scroll logic
            if (shouldAutoScroll && wordToScroll) {
                const containerRect = lyricsContainer.getBoundingClientRect();
                const wordRect = wordToScroll.getBoundingClientRect();
                const containerH = lyricsContainer.clientHeight;
                // Define scroll zones (e.g., scroll if word is outside middle 50%)
                const zoneTop = containerRect.top + containerH * 0.25;
                const zoneBottom = containerRect.bottom - containerH * 0.25;

                const isAboveZone = wordRect.top < zoneTop;
                const isBelowZone = wordRect.bottom > zoneBottom;
                const isLastWord = indexToHighlight === lyricsData.length - 1;

                 // If it's the last word and near the bottom, ensure it's fully visible
                 if (isLastWord && wordRect.bottom > containerRect.bottom - 20) {
                     wordToScroll.scrollIntoView({ behavior: 'smooth', block: 'end' });
                 }
                 // Otherwise, if outside the comfortable center zone, scroll it to center
                 else if (isAboveZone || isBelowZone) {
                    wordToScroll.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
             }
             // Instant scroll logic for seeking (if word is off-screen)
             else if (isSeeking && wordToScroll) {
                  const cRect = lyricsContainer.getBoundingClientRect();
                  const wRect = wordToScroll.getBoundingClientRect();
                  // If the word is completely outside the viewport after a seek
                  if (wRect.bottom < cRect.top || wRect.top > cRect.bottom) {
                      wordToScroll.scrollIntoView({ behavior: 'auto', block: 'center' }); // 'auto' for instant scroll
                  }
             }
        }


        function updateVolumeIcon(volume) {
            if (!volumeIcon) return;
            volumeIcon.className = 'fas '; // Reset classes
            if (volume <= 0) {
                volumeIcon.classList.add('fa-volume-mute');
            } else if (volume < 0.5) {
                volumeIcon.classList.add('fa-volume-down');
            } else {
                volumeIcon.classList.add('fa-volume-up');
            }
        }
        // Helper function to set volume and update UI/storage
        function setVolume(newVolume) {
             if (gainNode && audioContext) {
                const clampedVolume = Math.max(0, Math.min(1, newVolume));
                // Use setValueAtTime for smooth volume changes if needed, or just set value for immediate change
                gainNode.gain.setValueAtTime(clampedVolume, audioContext.currentTime);
                // Update UI elements
                volumeSlider.value = clampedVolume;
                updateVolumeIcon(clampedVolume);
                volumePercentage.textContent = `${Math.round(clampedVolume * 100)}%`;
                // Save the setting
                saveSetting(VOLUME_STORAGE_KEY, clampedVolume);
            }
        }

        function togglePopup(el) { el.classList.toggle('show'); }
        function hidePopup(el) { el.classList.remove('show'); }
        function formatTime(seconds) {
            if (isNaN(seconds) || !isFinite(seconds) || seconds < 0) return '0:00';
            const totalSeconds = Math.floor(seconds);
            const minutes = Math.floor(totalSeconds / 60);
            const secs = totalSeconds % 60;
            return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
        }


        // --- Keyboard Shortcuts ---
        document.addEventListener('keydown', handleKeyboardShortcuts);

        function handleKeyboardShortcuts(event) {
            // Ignore shortcuts if focus is on an element that expects typing,
            // unless it's one of our controls where shortcuts might still be desirable (like sliders).
            const activeElement = document.activeElement;
            const isTextInputFocused = (activeElement.tagName === 'INPUT' && /text|search|password|email|number|tel|url/.test(activeElement.type)) ||
                                      activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable;

            if (isTextInputFocused) {
                 return; // Don't interfere with text input
            }

            const playerReady = audioLoaded && lyricsLoaded && !!audioContext && !!audioBuffer;
            const isRangeInputFocused = activeElement.tagName === 'INPUT' && activeElement.type === 'range';

            // Calculate current precise time for seeking operations
            let currentBufferTime = startOffset;
             if (isPlaying && audioContext && startTime > 0) {
                 const elapsedRealTime = audioContext.currentTime - startTime;
                  // Calculate potential time, considering the loop possibility
                 let potentialTime = startOffset + (elapsedRealTime * currentPlaybackRate);
                 currentBufferTime = potentialTime % audioBuffer.duration; // Use modulo to get effective time within duration
             }
            // Clamp just in case, safety measure
            currentBufferTime = Math.max(0, Math.min(currentBufferTime, audioBuffer?.duration ?? 0));


            switch (event.code) {
                case 'Space':
                case 'KeyK':
                    // Allow space default only if focused on button/slider etc.
                    if (playerReady && activeElement.tagName !== 'BUTTON' && !isRangeInputFocused) {
                        event.preventDefault(); // Prevent page scroll if focus is elsewhere
                        togglePlayback();
                    } else if (playerReady && (activeElement.tagName === 'BUTTON' || isRangeInputFocused)) {
                        // If focus is on a button or slider, Space might activate it,
                        // but we still want it to toggle playback.
                         event.preventDefault(); // Prevent default button activation/slider step
                         togglePlayback();
                    }
                    break;

                case 'KeyJ': // Back 10s
                    if (playerReady) {
                        event.preventDefault(); // Prevent default browser actions if any
                        const newTime = Math.max(0, currentBufferTime - 10);
                        seekAudio(newTime);
                    }
                    break;

                case 'KeyL': // Forward 10s
                    if (playerReady) {
                        event.preventDefault();
                        const newTime = Math.min(audioBuffer.duration, currentBufferTime + 10);
                        seekAudio(newTime);
                    }
                    break;

                case 'ArrowLeft': // Back 5s
                    // If a range input has focus, let the default behavior handle it.
                    if (!isRangeInputFocused && playerReady) {
                        event.preventDefault(); // Prevent page scroll etc.
                        const newTime = Math.max(0, currentBufferTime - 5);
                        seekAudio(newTime);
                    }
                    // If range input focused, do nothing extra - allow default arrow key slider control.
                    break;

                case 'ArrowRight': // Forward 5s
                     // If a range input has focus, let the default behavior handle it.
                    if (!isRangeInputFocused && playerReady) {
                        event.preventDefault(); // Prevent page scroll etc.
                        const newTime = Math.min(audioBuffer.duration, currentBufferTime + 5);
                        seekAudio(newTime);
                    }
                    // If range input focused, do nothing extra.
                    break;

                case 'ArrowUp': // Volume Up 5%
                    // If a range input has focus, let the default behavior handle it.
                    if (!isRangeInputFocused && playerReady && gainNode && audioContext) {
                        event.preventDefault(); // Prevent page scroll
                        let currentVolume = gainNode.gain.value;
                        let newVolume = Math.min(1, currentVolume + 0.05);
                        setVolume(newVolume); // Use helper function
                    }
                    // If range input focused, do nothing extra.
                    break;

                case 'ArrowDown': // Volume Down 5%
                     // If a range input has focus, let the default behavior handle it.
                    if (!isRangeInputFocused && playerReady && gainNode && audioContext) {
                        event.preventDefault(); // Prevent page scroll
                        let currentVolume = gainNode.gain.value;
                        let newVolume = Math.max(0, currentVolume - 0.05);
                        setVolume(newVolume); // Use helper function
                    }
                     // If range input focused, do nothing extra.
                    break;
            }
        }


    </script>

</body>
</html>