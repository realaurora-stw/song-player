<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Lyrics</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="icon" href="https://raw.githubusercontent.com/realaurora-stw/song-player/refs/heads/main/icons/notes.png" type="image/png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        :root {
            color-scheme: dark;
            --sidebar-width: 320px;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            font-family: 'Poppins', sans-serif;
            background-color: #000000;
            color: #f0f0f0;
            overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        body {
            display: flex;
            height: 100vh;
        }

        button, input, select, textarea {
            font-family: inherit;
        }

        #main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            height: 100%;
            transition: margin-right 0.3s ease-in-out;
            will-change: margin-right;
        }

        #main-content.sidebar-open {
            margin-right: var(--sidebar-width);
        }

        #lyrics-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 40px 5% 200px 5%;
            font-size: 2.8em;
            line-height: 1.6;
            display: flex;
            scroll-behavior: smooth;
            min-height: 0;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

       #lyrics-container::-webkit-scrollbar {
            display: none;
        }

        #lyrics-output {
            max-width: 900px;
            width: 100%;
            text-align: left;
        }


        #lyrics-output span {
            display: none;
            opacity: 0;
            transform: translateY(15px) scale(0.9);
            transform-origin: center left;
            color: #f0f0f0;
            margin: 0 0.1em;
            cursor: default;
            transition: opacity 0.45s ease-out,
                        transform 0.45s ease-out,
                        color 0.25s ease-in-out,
                        font-weight 0.25s ease-in-out;
            will-change: opacity, transform;
            pointer-events: none;
        }

        #lyrics-output span.visible {
            display: inline-block;
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        #lyrics-output span.highlighted {
            color: #50d060;
            font-weight: 600;
            transform: translateY(-1px) scale(1.05);
            transition-property: color, font-weight, transform;
            transition-duration: 0.25s, 0.25s, 0.15s;
            transition-timing-function: ease-in-out, ease-in-out, ease-out;
        }


        #lyrics-output.placeholder {
             display: block;
             opacity: 1;
             transform: none;
             color: #555;
             font-style: italic;
             text-align: center;
             margin: auto;
             font-weight: normal;
        }


        #controls-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #000000;
            padding: 15px 30px;
            border-top: 1px solid #0c0c0c;
            z-index: 10;
            color: #aaa;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, width 0.3s ease-in-out;
        }

        #main-content.sidebar-open #controls-container {
            width: calc(100% - var(--sidebar-width));
        }

        .file-inputs {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .file-inputs label {
            font-size: 0.9em;
        }

        .file-inputs input[type="file"] {
            font-size: 0.8em;
            max-width: 250px;
            color: #767676;
            font-family: inherit;
        }
        .file-inputs input[type="file"]::file-selector-button {
            padding: 5px 10px;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            background-color: #111;
            color: #ccc;
            cursor: pointer;
            font-size: 0.9em;
            margin-right: 10px;
            transition: background-color 0.2s, border-color 0.2s;
            font-family: inherit;
        }
        .file-inputs input[type="file"]::file-selector-button:hover {
            background-color: #252525;
        }

        .player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            position: relative;
        }

        #playPauseBtn {
            background-color: #040404;
            color: #767676;
            border: none;
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 12px;
            cursor: pointer;
            min-width: 80px;
            transition: background-color 0.2s, color 0.2s;
            font-family: inherit;
        }
        #playPauseBtn:hover:enabled {
             background-color: #1f1f1f;
        }

        #playPauseBtn:disabled {
            background-color: #141414;
            color: #666;
            cursor: not-allowed;
        }

        #progressBar {
            flex-grow: 1;
            max-width: 500px;
            cursor: pointer;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #0d0d0d;
            border-radius: 5px;
            outline: none;
            transition: background-color 0.2s;
        }

        #progressBar::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 16px;
          height: 16px;
          background: #2a2a2a;
          border-radius: 50%;
          cursor: pointer;
          transition: background-color 0.2s, transform 0.15s ease-out;
        }
         #progressBar:hover::-webkit-slider-thumb {
              background: #2e2e2e;
         }
         #progressBar:active::-webkit-slider-thumb {
             transform: scale(1.1);
         }


        #progressBar::-moz-range-thumb {
          width: 16px;
          height: 16px;
          background: #757575;
          border-radius: 50%;
          cursor: pointer;
          border: none;
          transition: background-color 0.2s, transform 0.15s ease-out;
        }
         #progressBar:hover::-moz-range-thumb {
              background: #888;
         }
         #progressBar:active::-moz-range-thumb {
             transform: scale(1.1);
         }


        #progressBar:disabled::-webkit-slider-thumb {
            background: #333;
            cursor: not-allowed;
            transition: none;
             transform: none;
        }
        #progressBar:disabled::-moz-range-thumb {
            background: #333;
            cursor: not-allowed;
             transition: none;
             transform: none;
        }
        #progressBar:disabled {
            cursor: not-allowed;
             background: #0a0a0a;
        }


        #currentTime, #totalDuration {
            font-size: 0.9em;
            min-width: 45px;
            text-align: center;
            color: #4c4c4c;
            font-family: inherit;
            white-space: nowrap;
            transition: color 0.3s ease;
        }

        #audioPlayer {
             display: none;
        }

        #loadStatus {
             font-size: 0.8em;
             color: #4c4c4c;
             margin-left: 15px;
             min-height: 1.2em;
             font-family: inherit;
             transition: color 0.3s ease;
        }


       .control-icon-btn {
            background: none;
            border: none;
            color: #4c4c4c;
            font-size: 1.2em;
            padding: 5px;
            cursor: pointer;
            transition: color 0.2s, transform 0.2s ease;
            line-height: 1;
            font-family: inherit;
       }
       .control-icon-btn:hover:enabled {
           color: #646464;
       }
       .control-icon-btn:disabled {
           cursor: not-allowed;
       }
       .control-icon-btn.active {
            color: #50d060;
        }

        .volume-control-wrapper,
        .speed-control-wrapper,
        .bass-control-wrapper,
        .underwater-control-wrapper,
        .muffled-control-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .popup-control {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background-color: #080808;
            padding: 15px 15px 15px 15px;
            border-radius: 12px;
            box-shadow: 0px -2px 10px rgba(0, 0, 0, 0.5);
            z-index: 20;
            width: 50px;
            height: 160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;

            visibility: hidden;
            opacity: 0;
            transition: opacity 0.25s ease-out, transform 0.25s ease-out, visibility 0s 0.25s, background-color 0.3s ease, box-shadow 0.3s ease;
            will-change: opacity, transform, visibility;
        }

        .slider-wrapper-vertical {
            width: 90px;
            height: 24px;
            transform: rotate(-90deg);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }

        .slider-vertical {
            -webkit-appearance: none;
            appearance: none;
            width: 90px;
            height: 8px;
            cursor: pointer;
            background: #171717;
            border-radius: 10px;
            outline: none;
            display: block;
            margin: 0;
            margin-right: 56px;
            transition: background-color 0.2s;
        }

        .slider-vertical::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; background: #ccc;
            border-radius: 50%; cursor: pointer; border: none;
            transition: background-color 0.2s;
        }
        .slider-vertical::-moz-range-thumb {
            width: 16px; height: 16px; background: #ccc;
            border-radius: 50%; cursor: pointer; border: none;
            transition: background-color 0.2s;
        }


        .slider-vertical:disabled { cursor: not-allowed; background: #444; }
        .slider-vertical:disabled::-webkit-slider-thumb { background: #666; cursor: not-allowed; }
        .slider-vertical:disabled::-moz-range-thumb { background: #666; cursor: not-allowed; }

        .popup-text-display {
            color: #f0f0f0;
            font-size: 0.8em;
            text-align: center;
            width: 100%;
            margin-top: auto;
            font-family: inherit;
            transition: color 0.3s ease;
        }


        .popup-control.show {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out, visibility 0s 0s, background-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        /* --- PLAYLIST STYLES --- */
        #playlist-sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: var(--sidebar-width);
            height: 100%;
            background-color: #080808;
            border-left: 1px solid #1a1a1a;
            z-index: 100;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out, background-color 0.3s ease, border-color 0.3s ease;
            display: flex;
            flex-direction: column;
            will-change: transform;
        }

        #playlist-sidebar.open {
            transform: translateX(0);
        }

        .playlist-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #1a1a1a;
            flex-shrink: 0;
            transition: border-color 0.3s ease;
        }

        .playlist-header h3 {
            font-size: 1.1em;
            font-weight: 600;
        }

        #playlist-controls {
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-around;
            border-bottom: 1px solid #1a1a1a;
            flex-shrink: 0;
            transition: border-color 0.3s ease;
        }

        #playlist-controls .control-icon-btn, 
        #playlist-file-input-label {
            font-size: 1.3em;
            padding: 8px;
            color: #777;
        }
        #playlist-controls .control-icon-btn:hover:enabled,
        #playlist-file-input-label:hover {
            color: #aaa;
        }

        #playlist-file-input {
            display: none;
        }

        #playlist-list {
            list-style: none;
            overflow-y: auto;
            flex-grow: 1;
            scrollbar-width: thin;
            scrollbar-color: #333 #111;
        }
        #playlist-list::-webkit-scrollbar { width: 8px; }
        #playlist-list::-webkit-scrollbar-track { background: #111; }
        #playlist-list::-webkit-scrollbar-thumb { background-color: #333; border-radius: 4px; border: 2px solid #111; }

        #playlist-list li {
            padding: 12px 15px;
            font-size: 0.9em;
            cursor: pointer;
            border-bottom: 1px solid #1a1a1a;
            transition: background-color 0.2s, border-color 0.3s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #playlist-list li:hover {
            background-color: #1c1c1c;
        }

        #playlist-list li.active {
            background-color: #252525;
            color: #50d060;
            font-weight: 600;
        }
        
        #playlist-list li.active .fa-play {
            display: inline-block;
        }

        #playlist-list li .fa-play {
            display: none;
            font-size: 0.8em;
        }
        
        #playlist-placeholder {
            padding: 40px 15px;
            text-align: center;
            font-style: italic;
            color: #555;
            font-size: 0.9em;
        }


        @media (max-width: 1024px) {
             :root { --sidebar-width: 280px; }
        }

        @media (max-width: 768px) {
            :root { --sidebar-width: 100%; }

            #main-content.sidebar-open {
                margin-right: 0;
                display: none; /* Hide main content when sidebar is open on mobile */
            }
             #main-content.sidebar-open #controls-container {
                width: 100%; /* Make sure controls take full width */
                display: none; /* Hide controls when playlist is open on mobile */
             }

             #lyrics-container {
                 font-size: 2em;
                 padding: 20px 5% 150px 5%;
             }
             .player-controls { gap: 10px; }
             #playPauseBtn { padding: 6px 10px; font-size: 0.9em; }
            #currentTime, #totalDuration { font-size: 0.8em; min-width: 40px; }
            .file-inputs label { font-size: 0.8em; }
           .control-icon-btn { font-size: 1.1em; }


           .popup-control {
               padding: 12px 10px 12px 10px;
               height: 140px;
           }
           .slider-wrapper-vertical {
               width: 75px;
               height: 22px;
               margin-bottom: 15px;
           }
           .slider-vertical {
               width: 75px;
               height: 6px;
           }
            .slider-vertical::-webkit-slider-thumb { width: 14px; height: 14px; }
            .slider-vertical::-moz-range-thumb { width: 14px; height: 14px; }
           .popup-text-display { font-size: 0.75em; }
        }

        body.light-mode { background-color: #ffffff; color: #1a1a1a; }
        body.light-mode #main-content.sidebar-open { background-color: #ffffff; }
        body.light-mode #lyrics-output span { color: #1a1a1a; }
        body.light-mode #lyrics-output span.highlighted { color: black; }
        body.light-mode #lyrics-output.placeholder { color: #888; }
        body.light-mode #controls-container { background-color: #ffffff; border-top: 1px solid #dddddd; color: #555; }
        body.light-mode .file-inputs input[type="file"] { color: #555; }
        body.light-mode .file-inputs input[type="file"]::file-selector-button { border: 1px solid #ccc; background-color: #eee; color: #333; }
        body.light-mode .file-inputs input[type="file"]::file-selector-button:hover { background-color: #ddd; }
        body.light-mode #playPauseBtn { background-color: #e0e0e0; color: #222; }
        body.light-mode #playPauseBtn:hover:enabled { background-color: #d0d0d0; }
        body.light-mode #playPauseBtn:disabled { background-color: #f0f0f0; color: #aaa; }
        body.light-mode #progressBar { background: #dddddd; }
        body.light-mode #progressBar::-webkit-slider-thumb { background: #aaaaaa; }
        body.light-mode #progressBar:hover::-webkit-slider-thumb { background: #888888; }
        body.light-mode #progressBar::-moz-range-thumb { background: #aaaaaa; }
        body.light-mode #progressBar:hover::-moz-range-thumb { background: #888888; }
        body.light-mode #progressBar:disabled::-webkit-slider-thumb { background: #cccccc; }
        body.light-mode #progressBar:disabled::-moz-range-thumb { background: #cccccc; }
        body.light-mode #progressBar:disabled { background: #eeeeee; }
        body.light-mode #currentTime, body.light-mode #totalDuration { color: #555; }
        body.light-mode #loadStatus { color: #777; }
        body.light-mode .control-icon-btn { color: #444; }
        body.light-mode .control-icon-btn:hover:enabled { color: #000; }
        body.light-mode .control-icon-btn:disabled { color: #bbbbbb; }
        body.light-mode .control-icon-btn.active { color: #1e8a2a; }
        body.light-mode .popup-control { background-color: #f8f8f8; box-shadow: 0px -2px 10px rgba(0, 0, 0, 0.1); }
        body.light-mode .slider-vertical { background: #cccccc; }
        body.light-mode .slider-vertical::-webkit-slider-thumb { background: #666666; }
        body.light-mode .slider-vertical::-moz-range-thumb { background: #666666; }
        body.light-mode .slider-vertical:disabled { background: #dddddd; }
        body.light-mode .slider-vertical:disabled::-webkit-slider-thumb { background: #aaaaaa; }
        body.light-mode .slider-vertical:disabled::-moz-range-thumb { background: #aaaaaa; }
        body.light-mode .popup-text-display { color: #333333; }
        body.light-mode #playlist-sidebar { background-color: #fdfdfd; border-left-color: #ddd; }
        body.light-mode .playlist-header, body.light-mode #playlist-controls { border-bottom-color: #ddd; }
        body.light-mode #playlist-controls .control-icon-btn, body.light-mode #playlist-file-input-label { color: #666; }
        body.light-mode #playlist-controls .control-icon-btn:hover:enabled, body.light-mode #playlist-file-input-label:hover { color: #222; }
        body.light-mode #playlist-list li { border-bottom-color: #ddd; }
        body.light-mode #playlist-list li:hover { background-color: #f0f0f0; }
        body.light-mode #playlist-list li.active { background-color: #e0e0e0; color: #1e8a2a; }
        body.light-mode #playlist-placeholder { color: #888; }
        body.light-mode #playlist-list::-webkit-scrollbar-track { background: #f0f0f0; }
        body.light-mode #playlist-list::-webkit-scrollbar-thumb { background-color: #ccc; border-color: #f0f0f0; }

    </style>
</head>
<body>
    <div id="main-content">
        <div id="lyrics-container">
            <p id="lyrics-output" class="placeholder">Load a .songlyrics file.</p>
        </div>

        <div id="controls-container">
            <div class="file-inputs">
                <input type="file" id="songLyricsFile" accept=".songlyrics, .mp3" title="Add a single song to playlist">
                 <span id="loadStatus"></span>
            </div>

            <audio id="audioPlayer" style="display: none;"></audio>
            <div class="player-controls">
                <button id="togglePlaylistBtn" class="control-icon-btn" title="Toggle Playlist"><i class="fas fa-list-ul"></i></button>
                <button id="playPauseBtn" disabled>▶ Play</button>
                <span id="currentTime">0:00</span>
                <input type="range" id="progressBar" value="0" step="0.01" disabled>
                <span id="totalDuration">0:00</span>


                <div class="volume-control-wrapper">
                    <button id="volumeBtn" class="control-icon-btn" disabled title="Volume">
                        <i class="fas fa-volume-up"></i>
                    </button>
                    <div id="volumePopup" class="popup-control">
                        <div class="slider-wrapper-vertical">
                            <input type="range" id="volumeSlider" class="slider-vertical" min="0" max="1" step="0.01" value="1" disabled>
                        </div>
                        <span id="volumePercentage" class="popup-text-display">100%</span>
                    </div>
                </div>


                <div class="speed-control-wrapper">
                    <button id="speedBtn" class="control-icon-btn" disabled title="Playback Speed">
                        <i class="fas fa-sliders-h"></i>
                    </button>
                    <div id="speedPopup" class="popup-control">
                        <div class="slider-wrapper-vertical">
                            <input type="range" id="speedSlider" class="slider-vertical" min="0.18" max="2" step="0.01" value="1" disabled>
                        </div>
                        <span id="speedRateDisplay" class="popup-text-display">1.00x</span>
                    </div>
                </div>

                <div class="bass-control-wrapper">
                    <button id="bassBoostBtn" class="control-icon-btn" disabled title="Bass Boost">
                        <i class="fas fa-headphones-alt"></i>
                    </button>
                    <div id="bassBoostPopup" class="popup-control">
                        <div class="slider-wrapper-vertical">
                            <input type="range" id="bassBoostSlider" class="slider-vertical" min="0" max="30" step="1" value="0" disabled>
                        </div>
                        <span id="bassBoostLevelDisplay" class="popup-text-display">0 dB</span>
                    </div>
                </div>
                
                <div class="underwater-control-wrapper">
                    <button id="underwaterBtn" class="control-icon-btn" disabled title="Underwater">
                        <i class="fas fa-tint"></i>
                    </button>
                    <div id="underwaterPopup" class="popup-control">
                        <div class="slider-wrapper-vertical">
                            <input type="range" id="underwaterSlider" class="slider-vertical" min="0" max="100" step="1" value="0" disabled>
                        </div>
                        <span id="underwaterLevelDisplay" class="popup-text-display">0%</span>
                    </div>
                </div>

                <div class="muffled-control-wrapper">
                    <button id="muffledBtn" class="control-icon-btn" disabled title="Muffled">
                        <i class="fas fa-door-closed"></i>
                    </button>
                    <div id="muffledPopup" class="popup-control">
                        <div class="slider-wrapper-vertical">
                            <input type="range" id="muffledSlider" class="slider-vertical" min="0" max="100" step="1" value="0" disabled>
                        </div>
                        <span id="muffledLevelDisplay" class="popup-text-display">0%</span>
                    </div>
                </div>

                <button id="downloadBtn" class="control-icon-btn" disabled title="Download Remix">
                    <i class="fas fa-download"></i>
                    <i class="fas fa-circle-notch fa-spin" style="display: none;"></i>
                </button>

                <button id="themeToggleBtn" class="control-icon-btn" title="Toggle Theme">
                    <i id="themeIcon" class="fas fa-sun"></i>
                </button>
            </div>
        </div>
    </div>
    
    <div id="playlist-sidebar">
        <div class="playlist-header">
            <h3>Playlist</h3>
            <button id="closePlaylistBtn" class="control-icon-btn" title="Close Playlist"><i class="fas fa-times"></i></button>
        </div>
        <div id="playlist-controls">
            <input type="file" id="playlistFileInput" accept=".songlyrics, .mp3" multiple>
            <label for="playlistFileInput" id="playlist-file-input-label" class="control-icon-btn" title="Add files to playlist"><i class="fas fa-plus"></i></label>
            <button id="shuffleBtn" class="control-icon-btn" title="Shuffle"><i class="fas fa-random"></i></button>
            <button id="loopSongBtn" class="control-icon-btn" title="Loop Song"><i class="fas fa-retweet"></i></button>
            <button id="loopPlaylistBtn" class="control-icon-btn" title="Loop Playlist"><i class="fas fa-infinity"></i></button>
        </div>
        <ul id="playlist-list">
            <p id="playlist-placeholder">Click the <i class="fas fa-plus"></i> to add songs.</p>
        </ul>
    </div>


    <script>
        // DOM Elements
        const mainContent = document.getElementById('main-content');
        const songLyricsFileInput = document.getElementById('songLyricsFile');
        const lyricsOutput = document.getElementById('lyrics-output');
        const lyricsContainer = document.getElementById('lyrics-container');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const progressBar = document.getElementById('progressBar');
        const currentTimeDisplay = document.getElementById('currentTime');
        const totalDurationDisplay = document.getElementById('totalDuration');
        const loadStatus = document.getElementById('loadStatus');
        const volumeBtn = document.getElementById('volumeBtn');
        const volumePopup = document.getElementById('volumePopup');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeIcon = volumeBtn.querySelector('i');
        const volumePercentage = document.getElementById('volumePercentage');
        const speedBtn = document.getElementById('speedBtn');
        const speedPopup = document.getElementById('speedPopup');
        const speedSlider = document.getElementById('speedSlider');
        const speedRateDisplay = document.getElementById('speedRateDisplay');
        const bassBoostBtn = document.getElementById('bassBoostBtn');
        const bassBoostPopup = document.getElementById('bassBoostPopup');
        const bassBoostSlider = document.getElementById('bassBoostSlider');
        const bassBoostLevelDisplay = document.getElementById('bassBoostLevelDisplay');
        const underwaterBtn = document.getElementById('underwaterBtn');
        const underwaterPopup = document.getElementById('underwaterPopup');
        const underwaterSlider = document.getElementById('underwaterSlider');
        const underwaterLevelDisplay = document.getElementById('underwaterLevelDisplay');
        const muffledBtn = document.getElementById('muffledBtn');
        const muffledPopup = document.getElementById('muffledPopup');
        const muffledSlider = document.getElementById('muffledSlider');
        const muffledLevelDisplay = document.getElementById('muffledLevelDisplay');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadIcon = downloadBtn.querySelector('.fa-download');
        const downloadSpinnerIcon = downloadBtn.querySelector('.fa-circle-notch');
        const themeToggleBtn = document.getElementById('themeToggleBtn');
        const themeIcon = document.getElementById('themeIcon');

        // Playlist DOM Elements
        const playlistSidebar = document.getElementById('playlist-sidebar');
        const togglePlaylistBtn = document.getElementById('togglePlaylistBtn');
        const closePlaylistBtn = document.getElementById('closePlaylistBtn');
        const playlistFileInput = document.getElementById('playlistFileInput');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const loopSongBtn = document.getElementById('loopSongBtn');
        const loopPlaylistBtn = document.getElementById('loopPlaylistBtn');
        const playlistList = document.getElementById('playlist-list');
        const playlistPlaceholder = document.getElementById('playlist-placeholder');


        // Audio & Player State
        let audioContext;
        let audioBuffer;
        let sourceNode;
        let gainNode;
        let bassFilterNode;
        let underwaterFilterNode;
        let muffledFilterNode;
        let isPlaying = false;
        let isPaused = false;
        let startTime = 0;
        let startOffset = 0;
        let currentPlaybackRate = 1.0;
        let animationFrameId = null;

        // Lyrics State
        let lyricsData = [];
        let currentWordSpans = [];
        let currentWordIndex = -1;
        let previousWordIndex = -1;
        let lyricsLoaded = false;

        // General State
        let isSeeking = false;
        let currentSongFilename = null;
        let isMuted = false;
        let previousVolumeBeforeMute = 1.0;

        // Playlist State
        let playlist = [];
        let currentPlaylistIndex = -1;
        let isShuffle = false;
        let isLoopSong = false;
        let isLoopPlaylist = false;

        // Local Storage Keys
        const VOLUME_STORAGE_KEY = 'playerVolumeSetting';
        const SPEED_STORAGE_KEY = 'playerSpeedSetting_v2';
        const BASS_BOOST_STORAGE_KEY = 'playerBassBoostSetting';
        const UNDERWATER_STORAGE_KEY = 'playerUnderwaterSetting';
        const MUFFLED_STORAGE_KEY = 'playerMuffledSetting';
        const THEME_STORAGE_KEY = 'playerTheme';
        const LIGHT_MODE_CLASS = 'light-mode';

        // Popup Timers
        let volumePopupTimeout = null;
        let speedPopupTimeout = null;
        let bassBoostPopupTimeout = null;
        let underwaterPopupTimeout = null;
        let muffledPopupTimeout = null;
        const POPUP_CLOSE_DELAY = 6000;


        // --- CORE PLAYER FUNCTIONS ---
        
        function isPlayerReady() {
            return !!audioContext && !!audioBuffer;
        }

        function getCurrentBufferTime() {
             let time = startOffset;
             if (isPlayerReady() && isPlaying && audioContext && startTime > 0) {
                 const elapsedRealTime = audioContext.currentTime - startTime;
                 time = startOffset + (elapsedRealTime * currentPlaybackRate);
             }
             return Math.max(0, Math.min(time, audioBuffer?.duration ?? 0));
        }

        function initializeAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    bassFilterNode = audioContext.createBiquadFilter();
                    bassFilterNode.type = 'lowshelf';
                    bassFilterNode.frequency.value = 250;
                    bassFilterNode.gain.value = 0;

                    underwaterFilterNode = audioContext.createBiquadFilter();
                    underwaterFilterNode.type = 'lowpass';
                    underwaterFilterNode.frequency.value = 22050;
                    underwaterFilterNode.Q.value = 1;

                    muffledFilterNode = audioContext.createBiquadFilter();
                    muffledFilterNode.type = 'lowpass';
                    muffledFilterNode.frequency.value = 22050;
                    muffledFilterNode.Q.value = 1; 

                    gainNode = audioContext.createGain();
                    
                    bassFilterNode.connect(underwaterFilterNode);
                    underwaterFilterNode.connect(muffledFilterNode);
                    muffledFilterNode.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    loadVolumeSetting();
                    loadSpeedSetting();
                    loadBassBoostSetting();
                    loadUnderwaterSetting();
                    loadMuffledSetting();

                } catch (e) {
                    console.error("Web Audio API is not supported in this browser.", e);
                    alert("Sorry, your browser doesn't support the required Web Audio API for this player.");
                    audioContext = null;
                }
            }
        }

        function resetPlayerStateForNewSong() {
            stopAudio();
            audioBuffer = null;
            lyricsData = [];
            lyricsLoaded = false;
            currentWordSpans = [];
            currentWordIndex = -1;
            previousWordIndex = -1;
            startOffset = 0;
            startTime = 0;
            isPaused = false;
            isPlaying = false;
            currentSongFilename = null;
            
            lyricsOutput.innerHTML = '';
            lyricsOutput.className = 'placeholder';
            lyricsContainer.scrollTop = 0;

            playPauseBtn.textContent = '▶ Play';
            progressBar.value = 0;
            progressBar.max = 1;
            currentTimeDisplay.textContent = '0:00';
            totalDurationDisplay.textContent = '0:00';
            
            checkEnablePlayer();
        }

        // --- PLAYLIST LOGIC ---
        
        function togglePlaylistSidebar() {
            playlistSidebar.classList.toggle('open');
            mainContent.classList.toggle('sidebar-open');
        }

        function handleFileSelection(files) {
            if (!files || files.length === 0) return;
            
            const wasEmpty = playlist.length === 0;

            for (const file of files) {
                const fileNameLower = file.name.toLowerCase();
                 if (fileNameLower.endsWith('.songlyrics') || fileNameLower.endsWith('.mp3')) {
                    playlist.push({
                        file: file,
                        name: file.name,
                        processed: false,
                        audioBuffer: null,
                        lyricsData: null
                    });
                }
            }

            renderPlaylist();
            
            if (wasEmpty && playlist.length > 0) {
                loadAndPlayTrack(0);
            }
        }
        
        function renderPlaylist() {
            playlistList.innerHTML = '';
            if (playlist.length === 0) {
                playlistList.appendChild(playlistPlaceholder);
            } else {
                playlist.forEach((track, index) => {
                    const li = document.createElement('li');
                    li.dataset.index = index;
                    li.title = track.name;

                    const icon = document.createElement('i');
                    icon.className = 'fas fa-play';
                    li.appendChild(icon);

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = track.name;
                    li.appendChild(nameSpan);

                    if (index === currentPlaylistIndex) {
                        li.classList.add('active');
                    }
                    li.addEventListener('click', () => loadAndPlayTrack(index));
                    playlistList.appendChild(li);
                });
            }
        }

        async function loadAndPlayTrack(index) {
            if (index < 0 || index >= playlist.length) return;
            
            resetPlayerStateForNewSong();
            currentPlaylistIndex = index;
            renderPlaylist();
            
            const track = playlist[index];
            currentSongFilename = track.name;
            loadStatus.textContent = `Loading ${track.name}...`;

            try {
                if (!track.processed) {
                    const arrayBuffer = await track.file.arrayBuffer();
                    const processedData = await parseFile(arrayBuffer, track.name);
                    track.audioBuffer = processedData.audioBuffer;
                    track.lyricsData = processedData.lyricsData;
                    track.processed = true;
                }
                
                audioBuffer = track.audioBuffer;
                lyricsData = track.lyricsData;
                lyricsLoaded = true;

                renderLyrics();
                updateTotalDurationDisplay();
                updateCurrentTimeDisplay(0);
                updateLyricsHighlight(0, true, false);
                loadStatus.textContent = 'File loaded.';
                checkEnablePlayer();
                playAudio();

            } catch (error) {
                loadStatus.textContent = `Error: ${error.message}`;
                console.error(`Error loading track ${index}:`, error);
                // Optionally, remove the broken track from the playlist
                // playlist.splice(index, 1);
                // renderPlaylist();
                playNextTrack(); // Try to play the next song
            }
        }

        function parseFile(arrayBuffer, fileName) {
            return new Promise((resolve, reject) => {
                initializeAudioContext();
                if (!audioContext) {
                    return reject(new Error("Audio system not ready."));
                }
                
                let localLyricsData = [];
                let audioDataOffset = 0;
                const fileNameLower = fileName.toLowerCase();

                if (fileNameLower.endsWith('.mp3')) {
                    // It's just an MP3 file
                    audioDataOffset = 0;
                } else if (fileNameLower.endsWith('.songlyrics')) {
                    // It's a combined file
                    const dataView = new DataView(arrayBuffer);
                    const magic = String.fromCharCode(...new Uint8Array(arrayBuffer, 0, 4));
                    if (magic !== "LYRX") {
                        return reject(new Error("Invalid .songlyrics file signature."));
                    }
                    const jsonLength = dataView.getUint32(4, false);
                    audioDataOffset = 8 + jsonLength;
                    
                    if (jsonLength > 0) {
                        try {
                            const jsonString = new TextDecoder().decode(new Uint8Array(arrayBuffer, 8, jsonLength));
                            const jsonData = JSON.parse(jsonString);
                            if (jsonData && Array.isArray(jsonData.segments)) {
                                jsonData.segments.forEach(segment => {
                                    segment.words?.forEach(word => {
                                        if (word && typeof word.start === 'number' && typeof word.text === 'string') {
                                            localLyricsData.push({ word: word.text.trim(), start: word.start });
                                        }
                                    });
                                });
                                localLyricsData.sort((a, b) => a.start - b.start);
                            }
                        } catch (e) {
                            console.warn("Could not parse lyrics JSON, proceeding with audio only.", e);
                        }
                    }
                }

                const audioData = arrayBuffer.slice(audioDataOffset);
                if (audioData.byteLength === 0) {
                    return reject(new Error("No audio data found in file."));
                }
                
                audioContext.decodeAudioData(audioData)
                    .then(buffer => {
                        if (!(buffer?.duration > 0)) {
                            reject(new Error("Decoded audio is empty."));
                        } else {
                            resolve({ audioBuffer: buffer, lyricsData: localLyricsData });
                        }
                    })
                    .catch(e => reject(new Error(`Audio decoding failed: ${e.message}`)));
            });
        }
        
        function playNextTrack() {
            if (!isPlaying) return; // Don't auto-advance if paused
            
            if (isLoopSong) {
                loadAndPlayTrack(currentPlaylistIndex);
                return;
            }

            let nextIndex;
            if (isShuffle) {
                if (playlist.length <= 1) {
                    nextIndex = 0;
                } else {
                    do {
                        nextIndex = Math.floor(Math.random() * playlist.length);
                    } while (nextIndex === currentPlaylistIndex);
                }
            } else {
                nextIndex = currentPlaylistIndex + 1;
            }

            if (nextIndex >= playlist.length) {
                if (isLoopPlaylist) {
                    nextIndex = 0;
                } else {
                    // End of playlist
                    resetPlayerStateForNewSong();
                    currentPlaylistIndex = -1;
                    renderPlaylist();
                    lyricsOutput.innerHTML = 'Playlist finished.';
                    return;
                }
            }
            
            loadAndPlayTrack(nextIndex);
        }

        // --- SETTINGS (VOLUME, SPEED, THEME, ETC.) ---

        function loadSetting(key, defaultValue, validator) {
             try {
                const savedValue = localStorage.getItem(key);
                if (savedValue !== null) {
                    if (key === THEME_STORAGE_KEY) {
                        if (validator(savedValue)) return savedValue;
                    } else {
                        const parsedValue = parseFloat(savedValue);
                        if (validator(parsedValue)) return parsedValue;
                    }
                    localStorage.removeItem(key);
                }
            } catch (e) { console.error("Error loading setting:", key, e); }
            return defaultValue;
        }

        function saveSetting(key, value) {
             try {
                localStorage.setItem(key, value.toString());
             } catch (e) {
                console.error("Error saving setting:", key, value, e);
            }
        }

        function loadVolumeSetting() {
            const vol = loadSetting(VOLUME_STORAGE_KEY, 1, v => !isNaN(v) && v>=0 && v<=1);
            if(gainNode && audioContext) gainNode.gain.value = vol;
            if(volumeSlider) {
                 volumeSlider.value = vol;
                 if(volumePercentage) volumePercentage.textContent = `${Math.round(vol * 100)}%`;
                 updateVolumeIcon(vol);
            }
            isMuted = false;
            previousVolumeBeforeMute = vol;
        }

        function loadSpeedSetting() {
            const speed = loadSetting(SPEED_STORAGE_KEY, 1, s => !isNaN(s) && s>=0.01 && s<=2);
             setPlaybackSpeed(speed, false);
             updateTotalDurationDisplay();
        }

        function loadBassBoostSetting() {
            const bassLevel = loadSetting(BASS_BOOST_STORAGE_KEY, 0, b => !isNaN(b) && b >= 0 && b <= 30);
            setBassBoost(bassLevel);
        }

        function loadUnderwaterSetting() {
            const underwaterLevel = loadSetting(UNDERWATER_STORAGE_KEY, 0, u => !isNaN(u) && u >= 0 && u <= 100);
            setUnderwaterEffect(underwaterLevel);
        }

        function loadMuffledSetting() {
            const muffledLevel = loadSetting(MUFFLED_STORAGE_KEY, 0, m => !isNaN(m) && m >= 0 && m <= 100);
            setMuffledEffect(muffledLevel);
        }

        function applyTheme(theme) {
            if (theme === 'light') {
                document.body.classList.add(LIGHT_MODE_CLASS);
                themeIcon.classList.replace('fa-sun', 'fa-moon');
                themeToggleBtn.title = 'Dark Mode';
                saveSetting(THEME_STORAGE_KEY, 'light');
            } else {
                document.body.classList.remove(LIGHT_MODE_CLASS);
                themeIcon.classList.replace('fa-moon', 'fa-sun');
                themeToggleBtn.title = 'Light Mode';
                saveSetting(THEME_STORAGE_KEY, 'dark');
            }
        }

        function loadTheme() {
            const savedTheme = loadSetting(THEME_STORAGE_KEY, 'dark', t => t === 'light' || t === 'dark');
            applyTheme(savedTheme);
        }

        function toggleTheme() {
            const isLightMode = document.body.classList.contains(LIGHT_MODE_CLASS);
            applyTheme(isLightMode ? 'dark' : 'light');
        }

        function setVolume(newVolume) {
             const clampedVolume = Math.max(0, Math.min(1, newVolume));
             if (gainNode && audioContext) gainNode.gain.setValueAtTime(clampedVolume, audioContext.currentTime);
             if (volumeSlider) {
                 volumeSlider.value = clampedVolume;
                 updateVolumeIcon(clampedVolume);
                 volumePercentage.textContent = `${Math.round(clampedVolume * 100)}%`;
                 if (!isMuted) saveSetting(VOLUME_STORAGE_KEY, clampedVolume);
            }
        }

        function setPlaybackSpeed(rate, adjustPlayback = true) {
            if (isNaN(rate)) return;
            const minSpeed = parseFloat(speedSlider?.min ?? 0.18);
            const maxSpeed = parseFloat(speedSlider?.max ?? 2);
            const newRate = Math.max(minSpeed, Math.min(maxSpeed, rate));

            const previousRate = currentPlaybackRate;
            currentPlaybackRate = newRate;

            if (speedSlider) speedSlider.value = newRate;
            if (speedRateDisplay) speedRateDisplay.textContent = `${newRate.toFixed(2)}x`;
            saveSetting(SPEED_STORAGE_KEY, newRate);
            updateTotalDurationDisplay();

            if (adjustPlayback && isPlaying && sourceNode?.playbackRate) {
                const elapsedRealTime = audioContext.currentTime - startTime;
                const elapsedBufferTime = elapsedRealTime * previousRate;
                startOffset = (startOffset + elapsedBufferTime);
                if (audioBuffer) startOffset = startOffset % audioBuffer.duration;
                startOffset = Math.max(0, startOffset);
                sourceNode.playbackRate.setValueAtTime(currentPlaybackRate, audioContext.currentTime);
                startTime = audioContext.currentTime;
                updateCurrentTimeDisplay(getCurrentBufferTime());
            }
        }

        function setBassBoost(levelInDb) {
            if (isNaN(levelInDb) || !bassFilterNode || !audioContext) return;
            const minBoost = parseFloat(bassBoostSlider?.min ?? 0);
            const maxBoost = parseFloat(bassBoostSlider?.max ?? 30);
            const newLevel = Math.max(minBoost, Math.min(maxBoost, levelInDb));
            bassFilterNode.gain.setValueAtTime(newLevel, audioContext.currentTime);
            if (bassBoostSlider) bassBoostSlider.value = newLevel;
            if (bassBoostLevelDisplay) bassBoostLevelDisplay.textContent = `${newLevel > 0 ? '+' : ''}${Math.round(newLevel)} dB`;
            saveSetting(BASS_BOOST_STORAGE_KEY, newLevel);
        }

        function setUnderwaterEffect(level) {
            if (isNaN(level) || !underwaterFilterNode || !audioContext) return;
            const minLevel = parseFloat(underwaterSlider?.min ?? 0);
            const maxLevel = parseFloat(underwaterSlider?.max ?? 100);
            const newLevel = Math.max(minLevel, Math.min(maxLevel, level));
            const normalizedValue = newLevel / maxLevel;
            const minFreq = 400, maxFreq = 22050, logMin = Math.log(minFreq), logMax = Math.log(maxFreq), scale = logMax - logMin;
            const targetFreq = Math.exp(logMax - (normalizedValue * scale));
            const targetQ = 1 + (normalizedValue * 4);
            underwaterFilterNode.frequency.setValueAtTime(targetFreq, audioContext.currentTime);
            underwaterFilterNode.Q.setValueAtTime(targetQ, audioContext.currentTime);
            if (underwaterSlider) underwaterSlider.value = newLevel;
            if (underwaterLevelDisplay) underwaterLevelDisplay.textContent = `${Math.round(newLevel)}%`;
            saveSetting(UNDERWATER_STORAGE_KEY, newLevel);
        }

        function setMuffledEffect(level) {
            if (isNaN(level) || !muffledFilterNode || !audioContext) return;
            const minLevel = parseFloat(muffledSlider?.min ?? 0);
            const maxLevel = parseFloat(muffledSlider?.max ?? 100);
            const newLevel = Math.max(minLevel, Math.min(maxLevel, level));
            const normalizedValue = newLevel / maxLevel;
            const minFreq = 700, maxFreq = 22050, logMin = Math.log(minFreq), logMax = Math.log(maxFreq), scale = logMax - logMin;
            const targetFreq = Math.exp(logMax - (normalizedValue * scale));
            const targetQ = 1 + (normalizedValue * 1.5);
            muffledFilterNode.frequency.setValueAtTime(targetFreq, audioContext.currentTime);
            muffledFilterNode.Q.setValueAtTime(targetQ, audioContext.currentTime);
            if (muffledSlider) muffledSlider.value = newLevel;
            if (muffledLevelDisplay) muffledLevelDisplay.textContent = `${Math.round(newLevel)}%`;
            saveSetting(MUFFLED_STORAGE_KEY, newLevel);
        }

        function toggleMute() {
            if (!audioContext || !gainNode) return;
            if (isMuted) {
                isMuted = false;
                setVolume(previousVolumeBeforeMute);
            } else {
                isMuted = true;
                previousVolumeBeforeMute = gainNode.gain.value;
                setVolume(0);
            }
        }

        // --- PLAYBACK CONTROL (PLAY, PAUSE, SEEK) ---

        function togglePlayback() {
            if (playlist.length === 0) return;
            if (currentPlaylistIndex === -1) {
                loadAndPlayTrack(0);
                return;
            }
            if (!isPlayerReady()) return;

            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    if (isPlaying) pauseAudio(); else playAudio();
                }).catch(e => console.error("AudioContext resume failed:", e));
            } else {
                if (isPlaying) pauseAudio(); else playAudio();
            }
        }

        function playAudio() {
            if (!isPlayerReady() || isPlaying) return;
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(playAudioInternal).catch(e => console.error("AudioContext resume failed:", e));
                return;
            }
            playAudioInternal();
        }

        function playAudioInternal() {
            if (isPlaying || !isPlayerReady()) return;
            startOffset = Math.max(0, Math.min(startOffset, audioBuffer.duration));
            if (startOffset >= audioBuffer.duration) startOffset = 0;

            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.playbackRate.setValueAtTime(currentPlaybackRate, audioContext.currentTime);
            sourceNode.connect(bassFilterNode);
            sourceNode.onended = () => {
                if(isPlaying) playNextTrack(); // Only advance if it ended naturally, not from stop/pause
            };
            startTime = audioContext.currentTime;
            sourceNode.start(0, startOffset);

            isPlaying = true;
            isPaused = false;
            playPauseBtn.textContent = '❚❚ Pause';
            startUpdatingTime();
        }

        function pauseAudio() {
            if (!isPlaying || !sourceNode || !audioContext) return;
            const elapsedRealTime = audioContext.currentTime - startTime;
            const elapsedBufferTime = elapsedRealTime * currentPlaybackRate;
            startOffset = (startOffset + elapsedBufferTime);
            if (audioBuffer) startOffset = startOffset % audioBuffer.duration;
            startOffset = Math.max(0, startOffset);
            stopAudioInternals();
            isPlaying = false;
            isPaused = true;
            playPauseBtn.textContent = '▶ Play';
            updateCurrentTimeDisplay(startOffset);
        }

        function stopAudioInternals() {
             if (sourceNode) {
                sourceNode.onended = null;
                try { sourceNode.stop(0); } catch (e) {}
                sourceNode.disconnect();
                sourceNode = null;
            }
            stopUpdatingTime();
        }

        function stopAudio() {
            stopAudioInternals();
            isPlaying = false;
        }

        function seekAudio(bufferTime) {
            if (!isPlayerReady()) return;
            const wasPlaying = isPlaying;
            stopAudio();
            startOffset = Math.max(0, Math.min(bufferTime, audioBuffer.duration));
            progressBar.value = startOffset;
            updateCurrentTimeDisplay(startOffset);
            updateLyricsHighlight(startOffset, true, false);
            if (wasPlaying) {
                 playAudio();
            } else {
                isPaused = true;
                playPauseBtn.textContent = '▶ Play';
            }
        }
        
        // --- UI & DISPLAY UPDATE FUNCTIONS ---

        function startUpdatingTime() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (!isPlaying || startTime <= 0 || !audioContext) startTime = audioContext.currentTime;
            
            function updateLoop() {
                if (!isPlaying || !isPlayerReady()) { animationFrameId = null; return; }
                const currentTime = getCurrentBufferTime();
                updateLyricsHighlight(currentTime, false, true);
                if (!isSeeking) updateCurrentTimeDisplay(currentTime);
                animationFrameId = requestAnimationFrame(updateLoop);
            }
            animationFrameId = requestAnimationFrame(updateLoop);
        }

        function stopUpdatingTime() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function checkEnablePlayer() {
            const playerReady = isPlayerReady() && playlist.length > 0;
            const anySongLoaded = playlist.length > 0;

            playPauseBtn.disabled = !anySongLoaded;
            progressBar.disabled = !playerReady;
            volumeBtn.disabled = !playerReady;
            volumeSlider.disabled = !playerReady;
            speedBtn.disabled = !playerReady;
            speedSlider.disabled = !playerReady;
            bassBoostBtn.disabled = !playerReady;
            bassBoostSlider.disabled = !playerReady;
            underwaterBtn.disabled = !playerReady;
            underwaterSlider.disabled = !playerReady;
            muffledBtn.disabled = !playerReady;
            muffledSlider.disabled = !playerReady;
            downloadBtn.disabled = !playerReady;

            if (!playerReady) {
                hidePopup(volumePopup); hidePopup(speedPopup); hidePopup(bassBoostPopup);
                hidePopup(underwaterPopup); hidePopup(muffledPopup);
            }
        }

        function renderLyrics() {
            lyricsOutput.innerHTML = '';
            currentWordSpans = [];
            currentWordIndex = -1;
            previousWordIndex = -1;
            lyricsContainer.scrollTop = 0;

            if (lyricsLoaded && lyricsData.length > 0) {
                lyricsOutput.className = '';
                lyricsContainer.style.justifyContent = 'flex-start';
                lyricsContainer.style.alignItems = 'flex-start';
                lyricsData.forEach((line, index) => {
                    const span = document.createElement('span');
                    span.textContent = line.word + ' ';
                    span.id = `word-${index}`;
                    span.dataset.startTime = line.start;
                    lyricsOutput.appendChild(span);
                    currentWordSpans.push(span);
                });
            } else {
                lyricsOutput.innerHTML = 'No lyrics available for this song.';
                lyricsOutput.className = 'placeholder';
                lyricsContainer.style.justifyContent = 'center';
                lyricsContainer.style.alignItems = 'center';
            }
        }

        function updateLyricsHighlight(currentBufferTime, forceUpdate = false, allowScroll = false) {
            if (!lyricsLoaded || currentWordSpans.length === 0) return;
            const effectiveTime = audioBuffer ? (currentBufferTime) : 0;
            
            let newWordIndex = -1;
            const lookaheadTime = effectiveTime + 0.05;
            for (let i = 0; i < lyricsData.length; i++) {
                if (lyricsData[i].start <= lookaheadTime) newWordIndex = i;
                else break;
            }

             if (newWordIndex !== currentWordIndex || forceUpdate) {
                const shouldScroll = allowScroll && !isSeeking && isPlaying;
                highlightWord(newWordIndex, shouldScroll);
                previousWordIndex = currentWordIndex;
                currentWordIndex = newWordIndex;
             }
        }

        function highlightWord(indexToHighlight, shouldAutoScroll = false) {
            let wordToScroll = null;
            currentWordSpans.forEach((span, index) => {
                const isVisible = index <= indexToHighlight;
                span.classList.toggle('visible', isVisible);
                const isHighlighted = index === indexToHighlight;
                span.classList.toggle('highlighted', isHighlighted);
                if(isHighlighted) wordToScroll = span;
            });
            if (indexToHighlight < 0) currentWordSpans.forEach(s => s.classList.remove('highlighted', 'visible'));

            if (shouldAutoScroll && wordToScroll) {
                const containerRect = lyricsContainer.getBoundingClientRect();
                const wordRect = wordToScroll.getBoundingClientRect();
                const zoneTop = containerRect.top + containerRect.height * 0.25;
                const zoneBottom = containerRect.top + containerRect.height * 0.75;
                if (wordRect.top < zoneTop || wordRect.bottom > zoneBottom) {
                    wordToScroll.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        function updateTotalDurationDisplay() {
             if (audioBuffer?.duration > 0 && currentPlaybackRate > 0 && isFinite(currentPlaybackRate)) {
                const adjustedDuration = audioBuffer.duration / currentPlaybackRate;
                totalDurationDisplay.textContent = formatTime(adjustedDuration);
                progressBar.max = audioBuffer.duration;
            } else {
                totalDurationDisplay.textContent = '0:00';
                progressBar.max = 1;
            }
        }

        function updateCurrentTimeDisplay(bufferTime) {
             const validBufferTime = (typeof bufferTime === 'number' && isFinite(bufferTime)) ? bufferTime : 0;
             const duration = audioBuffer?.duration ?? 0;
             let clampedBufferTime = Math.max(0, Math.min(validBufferTime, duration));
             if (duration > 0 && currentPlaybackRate > 0 && isFinite(currentPlaybackRate)) {
                const displayTime = clampedBufferTime / currentPlaybackRate;
                currentTimeDisplay.textContent = formatTime(displayTime);
                if (!isSeeking) progressBar.value = clampedBufferTime;
             } else {
                 currentTimeDisplay.textContent = '0:00';
                 if (!isSeeking) progressBar.value = 0;
             }
        }
        
        function updateVolumeIcon(volume) {
            if (!volumeIcon) return;
            volumeIcon.className = 'fas ';
            if (volume <= 0) volumeIcon.classList.add('fa-volume-mute');
            else if (volume < 0.5) volumeIcon.classList.add('fa-volume-down');
            else volumeIcon.classList.add('fa-volume-up');
        }

        function formatTime(seconds) {
            if (isNaN(seconds) || !isFinite(seconds) || seconds < 0) return '0:00';
            const totalSeconds = Math.floor(seconds);
            const minutes = Math.floor(totalSeconds / 60);
            const secs = totalSeconds % 60;
            return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
        }
        
        // --- POPUP CONTROLS ---

        function resetPopupTimer(popupElement) {
            clearPopupTimer(popupElement);
            const timerCallback = () => { hidePopup(popupElement); };
            if (popupElement === volumePopup) volumePopupTimeout = setTimeout(timerCallback, POPUP_CLOSE_DELAY);
            else if (popupElement === speedPopup) speedPopupTimeout = setTimeout(timerCallback, POPUP_CLOSE_DELAY);
            else if (popupElement === bassBoostPopup) bassBoostPopupTimeout = setTimeout(timerCallback, POPUP_CLOSE_DELAY);
            else if (popupElement === underwaterPopup) underwaterPopupTimeout = setTimeout(timerCallback, POPUP_CLOSE_DELAY);
            else if (popupElement === muffledPopup) muffledPopupTimeout = setTimeout(timerCallback, POPUP_CLOSE_DELAY);
        }

        function clearPopupTimer(popupElement) {
             if (popupElement === volumePopup && volumePopupTimeout) clearTimeout(volumePopupTimeout);
             else if (popupElement === speedPopup && speedPopupTimeout) clearTimeout(speedPopupTimeout);
             else if (popupElement === bassBoostPopup && bassBoostPopupTimeout) clearTimeout(bassBoostPopupTimeout);
             else if (popupElement === underwaterPopup && underwaterPopupTimeout) clearTimeout(underwaterPopupTimeout);
             else if (popupElement === muffledPopup && muffledPopupTimeout) clearTimeout(muffledPopupTimeout);
        }

        function togglePopup(el) { el.classList.toggle('show'); }
        function hidePopup(el) { el.classList.remove('show'); clearPopupTimer(el); }
        
        // --- EVENT LISTENERS ---

        document.addEventListener('DOMContentLoaded', () => {
             loadTheme();
             checkEnablePlayer();
             renderPlaylist();
        });

        // Playlist Listeners
        togglePlaylistBtn.addEventListener('click', togglePlaylistSidebar);
        closePlaylistBtn.addEventListener('click', togglePlaylistSidebar);
        playlistFileInput.addEventListener('change', (e) => handleFileSelection(e.target.files));
        songLyricsFileInput.addEventListener('change', (e) => handleFileSelection(e.target.files));

        shuffleBtn.addEventListener('click', () => {
            isShuffle = !isShuffle;
            shuffleBtn.classList.toggle('active', isShuffle);
        });

        loopSongBtn.addEventListener('click', () => {
            isLoopSong = !isLoopSong;
            loopSongBtn.classList.toggle('active', isLoopSong);
            if(isLoopSong) {
                isLoopPlaylist = false;
                loopPlaylistBtn.classList.remove('active');
            }
        });

        loopPlaylistBtn.addEventListener('click', () => {
            isLoopPlaylist = !isLoopPlaylist;
            loopPlaylistBtn.classList.toggle('active', isLoopPlaylist);
             if(isLoopPlaylist) {
                isLoopSong = false;
                loopSongBtn.classList.remove('active');
            }
        });

        // Player Control Listeners
        playPauseBtn.addEventListener('click', togglePlayback);
        themeToggleBtn.addEventListener('click', toggleTheme);

        progressBar.addEventListener('input', () => {
            if (!isPlayerReady()) return;
            isSeeking = true;
            stopUpdatingTime();
            updateCurrentTimeDisplay(parseFloat(progressBar.value));
            updateLyricsHighlight(parseFloat(progressBar.value), true, false);
        });

        progressBar.addEventListener('change', () => {
            if (!isPlayerReady()) return;
            isSeeking = false;
            seekAudio(parseFloat(progressBar.value));
        });

        // Popup Listeners
        volumeBtn.addEventListener('click', (e) => { e.stopPropagation(); if (!volumeBtn.disabled) togglePopup(volumePopup); resetPopupTimer(volumePopup); });
        speedBtn.addEventListener('click', (e) => { e.stopPropagation(); if (!speedBtn.disabled) togglePopup(speedPopup); resetPopupTimer(speedPopup); });
        bassBoostBtn.addEventListener('click', (e) => { e.stopPropagation(); if (!bassBoostBtn.disabled) togglePopup(bassBoostPopup); resetPopupTimer(bassBoostPopup); });
        underwaterBtn.addEventListener('click', (e) => { e.stopPropagation(); if (!underwaterBtn.disabled) togglePopup(underwaterPopup); resetPopupTimer(underwaterPopup); });
        muffledBtn.addEventListener('click', (e) => { e.stopPropagation(); if (!muffledBtn.disabled) togglePopup(muffledPopup); resetPopupTimer(muffledPopup); });
        
        document.addEventListener('click', (event) => {
            hidePopup(volumePopup); hidePopup(speedPopup); hidePopup(bassBoostPopup);
            hidePopup(underwaterPopup); hidePopup(muffledPopup);
        });
        
        [volumePopup, speedPopup, bassBoostPopup, underwaterPopup, muffledPopup].forEach(p => {
            p.addEventListener('click', e => e.stopPropagation());
            p.addEventListener('mousemove', () => resetPopupTimer(p));
        });
        
        volumeSlider.addEventListener('input', () => { setVolume(parseFloat(volumeSlider.value)); resetPopupTimer(volumePopup); });
        speedSlider.addEventListener('input', () => { setPlaybackSpeed(parseFloat(speedSlider.value)); resetPopupTimer(speedPopup); });
        bassBoostSlider.addEventListener('input', () => { setBassBoost(parseFloat(bassBoostSlider.value)); resetPopupTimer(bassBoostPopup); });
        underwaterSlider.addEventListener('input', () => { setUnderwaterEffect(parseFloat(underwaterSlider.value)); resetPopupTimer(underwaterPopup); });
        muffledSlider.addEventListener('input', () => { setMuffledEffect(parseFloat(muffledSlider.value)); resetPopupTimer(muffledPopup); });


        // --- DOWNLOAD FUNCTIONALITY ---

        downloadBtn.addEventListener('click', handleDownload);
        
        async function handleDownload() {
            if (!isPlayerReady()) {
                alert("Please load a song first.");
                return;
            }

            downloadIcon.style.display = 'none';
            downloadSpinnerIcon.style.display = 'inline-block';
            downloadBtn.disabled = true;
            loadStatus.textContent = 'Processing download...';

            try {
                const adjustedLyricsForFile = lyricsData.map(w => ({
                    text: w.word,
                    start: w.start / currentPlaybackRate
                }));
                const lyricsJson = { segments: [{ words: adjustedLyricsForFile }] };
                const jsonString = JSON.stringify(lyricsJson);
                const jsonBytes = new TextEncoder().encode(jsonString);

                if (!audioBuffer) throw new Error("Audio buffer is not available.");

                const targetDuration = audioBuffer.duration / currentPlaybackRate;
                if (targetDuration <= 0 || !isFinite(targetDuration) || targetDuration > 60 * 45) {
                     throw new Error(`The selected speed results in audio too long to process.`);
                }

                const offlineCtx = new OfflineAudioContext(audioBuffer.numberOfChannels, Math.ceil(targetDuration * audioBuffer.sampleRate), audioBuffer.sampleRate);
                const offlineSource = offlineCtx.createBufferSource();
                offlineSource.buffer = audioBuffer;
                offlineSource.playbackRate.value = currentPlaybackRate;

                const offlineBassFilter = offlineCtx.createBiquadFilter();
                offlineBassFilter.type = bassFilterNode.type;
                offlineBassFilter.frequency.value = bassFilterNode.frequency.value;
                offlineBassFilter.gain.value = bassFilterNode.gain.value;

                const offlineUnderwaterFilter = offlineCtx.createBiquadFilter();
                offlineUnderwaterFilter.type = underwaterFilterNode.type;
                offlineUnderwaterFilter.frequency.value = underwaterFilterNode.frequency.value;
                offlineUnderwaterFilter.Q.value = underwaterFilterNode.Q.value;

                const offlineMuffledFilter = offlineCtx.createBiquadFilter();
                offlineMuffledFilter.type = muffledFilterNode.type;
                offlineMuffledFilter.frequency.value = muffledFilterNode.frequency.value;
                offlineMuffledFilter.Q.value = muffledFilterNode.Q.value;

                offlineSource.connect(offlineBassFilter);
                offlineBassFilter.connect(offlineUnderwaterFilter);
                offlineUnderwaterFilter.connect(offlineMuffledFilter);
                offlineMuffledFilter.connect(offlineCtx.destination);
                offlineSource.start(0);

                const renderedBuffer = await offlineCtx.startRendering();
                const audioWavArrayBuffer = audioBufferToWav(renderedBuffer);
                
                const magic = new TextEncoder().encode("LYRX");
                const jsonLengthBytes = new ArrayBuffer(4);
                new DataView(jsonLengthBytes).setUint32(0, jsonBytes.length, false);

                const combinedData = new Blob([magic, jsonLengthBytes, jsonBytes, audioWavArrayBuffer], { type: 'application/octet-stream' });
                
                let baseFilename = currentSongFilename ? currentSongFilename.replace(/\.[^/.]+$/, "") : "remix";
                const downloadFilename = `${baseFilename} [auroraverse.shop].songlyrics`;

                const url = URL.createObjectURL(combinedData);
                const a = document.createElement('a');
                a.href = url;
                a.download = downloadFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                loadStatus.textContent = 'Download ready!';
            } catch (error) {
                console.error("Error during download processing:", error);
                alert(`Failed to process download: ${error.message}`);
                loadStatus.textContent = `Download error: ${error.message}`;
            } finally {
                downloadIcon.style.display = 'inline-block';
                downloadSpinnerIcon.style.display = 'none';
                downloadBtn.disabled = !isPlayerReady();
            }
        }
        
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels, sampleRate = buffer.sampleRate, numFrames = buffer.length;
            const bitsPerSample = 16, blockAlign = numChannels * (bitsPerSample / 8), byteRate = sampleRate * blockAlign, dataSize = numFrames * blockAlign;
            const wavBuffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(wavBuffer);
            const writeString = (offset, str) => { for (let i=0; i<str.length; i++) view.setUint8(offset+i, str.charCodeAt(i)); };
            
            writeString(0, 'RIFF'); view.setUint32(4, 36 + dataSize, true); writeString(8, 'WAVE');
            writeString(12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true); view.setUint16(34, bitsPerSample, true);
            writeString(36, 'data'); view.setUint32(40, dataSize, true);

            const pcm = new Int16Array(wavBuffer, 44);
            for (let i = 0; i < numFrames; i++) {
                for (let ch = 0; ch < numChannels; ch++) {
                    let sample = buffer.getChannelData(ch)[i];
                    sample = Math.max(-1, Math.min(1, sample));
                    pcm[i * numChannels + ch] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                }
            }
            return wavBuffer;
        }

    </script>

</body>
</html>
